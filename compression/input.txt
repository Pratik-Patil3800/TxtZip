huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}
huffman coding is a data compression algorithm. it assigns shorter codes to frequent characters and longer codes to infrequent ones.
# include<iostream>
#include<queue>
#include <unordered_map>
#include <fstream>
#include <vector>
#include <bitset>
#include <cstring>
using namespace std;

class node{
    public:
    char data;
    int freq;
    node* left;
    node* right;
    node(char data,int freq){
        this->data=data;
        this->freq=freq;
        this->left=NULL;
        this->right=NULL;
    }
};

struct CompareNodes {
    bool operator()(const node* a, const node* b) const {
        return a->freq > b->freq;
    }
};

string header(const unordered_map<char, string>& codes, int offset) {
    string headerStr="";
    for (const auto& pair : codes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}

node* hofmantree(unordered_map<char, int>& freqMap){
    priority_queue<node*,vector<node*>, CompareNodes> pq;
    for (auto& pair : freqMap) {
        pq.push(new node(pair.first, pair.second));
    }
    
    while (pq.size()>1) {
        node* left = pq.top(); pq.pop();
        node* right = pq.top(); pq.pop();
        node* parent = new node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }
    return pq.top();
}

void generateHuffmanCodes(node* root, string code, unordered_map<char, string>& codes) {
    if (root == nullptr) return;

    if (root->data != '$') {
        codes[root->data] = code;
    }
    generateHuffmanCodes(root->left, code + "0", codes);
    generateHuffmanCodes(root->right, code + "1", codes);
}



void writeEncodedData(const string& filecontent, const unordered_map<char, string>& codes, const string& outputFileName) {
    ofstream outputFile(outputFileName, ios::binary);
    if (outputFile.is_open()) {
       
        unsigned char buffer = 0; 
        int bitsInBuffer = 0; 
        
        for (char c : filecontent) {
            for (char bit : codes.at(c)) {
                buffer = (buffer << 1) | (bit - '0');
                bitsInBuffer++;
                
                if (bitsInBuffer == 8) {
                    outputFile.put(buffer);
                    buffer = 0;
                    bitsInBuffer = 0;
                }
            }
        }
        int offset=bitsInBuffer;
        if (bitsInBuffer > 0) {
            buffer <<= (8 - bitsInBuffer);
            outputFile.put(buffer);
        }

        string codesHeader = header(codes, offset);
        for (char c : codesHeader) {
            outputFile.put(c);
        }
        
        outputFile.close();
        cout << "Compressed data written to " << outputFileName << endl;
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputFileName << endl;
    }
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    string binaryString;
    if (file.is_open()) {
        file.seekg(0, ios::end);
        streampos fileSize = file.tellg();
        file.seekg(0, ios::beg);
        binaryString.resize(fileSize);
        file.read(&binaryString[0], fileSize);
        file.close();
    } else {
        cerr << "Error: Unable to open file for readBinaryDataFromFile" << filename << endl;
    }
    return binaryString;
}

string* reverseencoding(const string& filename){
    string* filecontent=new string (readBinaryDataFromFile(filename));
    int i=0;
    string* encodin=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            i++;
            break;
        }
        encodin->push_back((*filecontent)[i]);
        i++;
    }
    unordered_map<string,char>* mp=new unordered_map<string,char>();
    string* temp=new string("");
    while(i<filecontent->size()){
        if((*filecontent)[i]==''){
            (*mp)[temp->substr(1)]=(*temp)[0];
            temp->clear();
        }
        else{
            temp->push_back((*filecontent)[i]);
        }
        i++;
    }
    int offset=8-stoi(*temp);
    string binaryString;
    for (char c : *encodin) {
        binaryString += bitset<8>(c).to_string();
    }
    string* ans=new string("");
    string* findkey=new string("");
    for(int i=0;i<binaryString.length()-offset;i++){
        findkey->push_back(binaryString[i]);
        if(mp->find(*findkey)!=mp->end()){
            ans->push_back((*mp)[*findkey]);
            findkey->clear();
        }
    }
    delete filecontent;
    delete encodin;
    delete mp;
    delete temp;
    // delete binaryString;
    delete findkey;
    return ans;
}

void compress(const string& filename){
    ifstream inputFile(filename, ios::binary);
    if (!inputFile.is_open()) {
        cerr << "Error: Unable to open input file." << endl;
    }
    else{
        // unordered_map<char, int> freqMap;
        string encodedText;
        string text((istreambuf_iterator<char>(inputFile)), (istreambuf_iterator<char>()));
        inputFile.close();

        unordered_map<char, int> freqMap;
        for (char c : text) {
            freqMap[c]++;
        }
        node* root=hofmantree(freqMap);
        unordered_map<char, string> codes;
        generateHuffmanCodes(root,"",codes);
        // encodedText = encodeText(text, codes);
        string outputfilename="";
        for(int i=0;i<filename.size();i++){
            if(filename[i]=='.'){
                break;
            }
            outputfilename.push_back(filename[i]);
        }
        outputfilename+=".bin";
        writeEncodedData(text, codes, outputfilename);
    } 
}

void decompress(const string& filename){
    string* ans=reverseencoding(filename);
    string outputfilename="";
    for(int i=0;i<filename.size();i++){
        if(filename[i]=='.'){
            break;
        }
        outputfilename.push_back(filename[i]);
    }
    outputfilename+=".txt";
    
    ofstream outputFile(outputfilename);
    if (outputFile.is_open()) {
        outputFile << ans;
        outputFile.close();
    } else {
        cerr << "Error: Unable to open output file for writeEncodedData " << outputfilename << endl;
    }
}

int main(int argc,char** argv){
    cout<<argv[1]<<" "<<argv[2]<<endl;
     if (strcmp(argv[1], "compress") == 0) {
        compress(argv[2]);
    } else {
        decompress(argv[2]);
    }
    return 0;
}

const express = require('express');
const { exec } = require('child_process');
const multer=require('multer');
const fs = require('fs');
const expressLayouts = require('express-ejs-layouts');
const path=require('path');

const app = express();
app.use(express.static('stylesheet'));

app.set('view engine', 'ejs');
app.use(expressLayouts);
app.get('/home', (req, res) => {
    res.render('home', { title: 'home' });
    
});
app.get('/compress', (req, res) => {
    res.render('compress', { title: 'home' });
    
});
app.get('/decompress', (req, res) => {
    res.render('decompress', { title: 'home' });
    
});

const storage=multer.diskStorage({
    destination:function(req,file,cb){
        return cb(null,".");
    },
    filename:function(req,file,cb){
        return cb(null,${file.originalname});
    }
})
const upload=multer({storage});
app.post('/compress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = wine "${exePath}" compress "${req.file.path}";

   
    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.bin, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.bin, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

app.post('/decompress',upload.single("fileinput"), (req, res) => {
    const exePath = path.join(__dirname, 'example.exe'); 
    const command = "${exePath}" decompress "${req.file.path}";

    exec(command, (error, stdout, stderr) => {
        if (error) {
            console.error(Error executing command: ${error});
            return;
        }
            console.log(Output: ${stdout});

            console.error(Errors: ${stderr});
    });
    const filenameWithExtension = path.basename(req.file.path);
    setTimeout(function() {
        res.download(${path.parse(filenameWithExtension).name}.txt, (err) => {
            if (err) {
                console.error('Error downloading file:', err);
            } else {
                console.log('File downloaded successfully');
                fs.unlink(req.file.path, (err) => {
                    if (err) {
                        console.error('Error deleting original file:', err);
                    } else {
                        console.log('Original file deleted successfully');
                    }
                });
                fs.unlink(${path.parse(filenameWithExtension).name}.txt, (err) => {
                    if (err) {
                        console.error('Error deleting downloaded file:', err);
                    } else {
                        console.log('Downloaded file deleted successfully');
                    }
                });
            }
        });
    }, 3000);
});

const PORT = process.env.PORT || 8090;
app.listen(PORT, () => {
    console.log(Server is running on port ${PORT});
});

#include "HuffmanCoding.hpp"
#include <fstream>
#include <iostream>
#include <bitset>

// Constructor
HuffmanCoding::HuffmanCoding() {

 }

// Destructor
HuffmanCoding::~HuffmanCoding() {
    // Optional: implement recursive delete if no smart pointers are used
}

// Build frequency table from text
void HuffmanCoding::buildFrequencyTable(const string& text) {
    freqTable.clear();
    for (char ch : text) {
        freqTable[ch]++;
    }
}

// Build Huffman Tree from frequency table
void HuffmanCoding::buildTree() {
    priority_queue<Node*, vector<Node*>, Compare> pq;

    for (auto& pair : freqTable) {
        pq.push(new Node(pair.first, pair.second));
    }

    while (pq.size() > 1) {
        Node* left = pq.top(); pq.pop();
        Node* right = pq.top(); pq.pop();

        Node* parent = new Node('$', left->freq + right->freq);
        parent->left = left;
        parent->right = right;
        pq.push(parent);
    }

    root= pq.empty() ? nullptr : pq.top();
}

// Recursively generate Huffman codes
void HuffmanCoding::generateCodes(Node* node, const string& code) {
    if (!node) return;

    if (node->isLeaf()) {
        huffmanCodes[node->ch] = code;
        return;
    }

    generateCodes(node->left, code + "0");
    generateCodes(node->right, code + "1");
}

// Encodes the input text using the generated Huffman codes

string HuffmanCoding::getHeader(int offset) {
    string headerStr="";
    for (const auto& pair : huffmanCodes) {
        headerStr += pair.first; 
        headerStr +=pair.second + ""; 
    }
    headerStr += to_string(offset);
    return headerStr;
}
int HuffmanCoding::encode(const string& fileName) {
    ifstream in(fileName);
    if (!in) {
        cerr << "Failed to open input file: " << fileName << endl;
        return 1;
    }
    string content((istreambuf_iterator<char>(in)), istreambuf_iterator<char>());
    in.close();
    buildFrequencyTable(content);
    buildTree();  // make sure you store root
    generateCodes(root, "");

    ofstream outputFile("output.txt", std::ios::binary);
    if (!outputFile) {
        cerr << "Failed to open output file.\n";
        return 0;
    }

    string encodedStr;
    unsigned char buffer = 0;
    int bitsInBuffer = 0;

    for (char c : content) {
        const string& code = huffmanCodes.at(c);
        for (char bit : code) {
            buffer = (buffer << 1) | (bit - '0');
            bitsInBuffer++;

            if (bitsInBuffer == 8) {
                outputFile.put(buffer);
                buffer = 0;
                bitsInBuffer = 0;
            }
        }
    }

    int padding = 0;
    if (bitsInBuffer > 0) {
        padding = 8 - bitsInBuffer;
        buffer <<= padding; // pad remaining bits with 0s
        outputFile.put(buffer);
    }

    // Save padding info as last byte
    string codesHeader = getHeader(padding);
    for (char c : codesHeader) {
        outputFile.put(c);
    }

    outputFile.close();

    return 0;
}

string readBinaryDataFromFile(const string& filename) {
    ifstream file(filename, ios::binary);
    if (!file) {
        cerr << "Error opening file: " << filename << endl;
        return "";
    }
    string data((istreambuf_iterator<char>(file)), istreambuf_iterator<char>());
    return data;
}

// Decode the encoded string using the Huffman tree
int HuffmanCoding::decode(const string& filename)  {
    string fileContent = readBinaryDataFromFile(filename);
    if (fileContent.empty()) return 0;

    size_t i = 0;
    string encodedBytes;
    
    // Read encoded bytes (until first '')
    while (i < fileContent.size() && fileContent[i] != '') {
        encodedBytes += fileContent[i++];
    }

    ++i; // skip the '' delimiter

    // Read Huffman map
    unordered_map<string, char> codeToChar;
    string temp;
    while (i < fileContent.size()) {
        if (fileContent[i] == '') {
            // temp format: ch + code => ex: A1001 => map["1001"] = 'A'
            codeToChar[temp.substr(1)] = temp[0];
            temp.clear();
        } else {
            temp += fileContent[i];
        }
        ++i;
    }

    // Get padding (offset) from last part of temp
    int offset = 8 - stoi(temp);

    // Convert encoded bytes to binary string
    string binaryStr;
    for (char c : encodedBytes) {
        binaryStr += bitset<8>(static_cast<unsigned char>(c)).to_string();
    }

    // Decode binary string using Huffman map
    string decodedText;
    string key;
    for (size_t j = 0; j < binaryStr.size() - offset; ++j) {
        key += binaryStr[j];
        if (codeToChar.count(key)) {
            decodedText += codeToChar[key];
            key.clear();
        }
    }

    // Write output to a decoded file
    ofstream output("decoded_output.txt");
    if (!output) {
        cerr << "Failed to write decoded output." << endl;
        return 1;
    }
    output << decodedText;
    output.close();
    return 1;
}

// ---------- Node Methods ----------

HuffmanCoding::Node::Node(char character, int frequency)
    : ch(character), freq(frequency), left(nullptr), right(nullptr) { }

bool HuffmanCoding::Node::isLeaf() const {
    return !left && !right;
}

// ---------- Compare Struct ----------

bool HuffmanCoding::Compare::operator()(const Node* a, const Node* b) {
    return a->freq > b->freq; // Min-heap: lower freq = higher priority
}